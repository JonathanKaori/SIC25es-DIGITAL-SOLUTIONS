# -*- coding: utf-8 -*-
"""MODELO (3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15Ph18rkTn_H9EBwvXJ9aildRPWhT_u1e

# __ETAPA 1: CARGAR Y EXPLORAR LOS DATOS__
"""

import pandas as pd

# Cargar el archivo CSV
df = pd.read_csv(r"C:\Users\Angel Temporal\CANASTA BASICA PROYECTO\DATA SET\URBANA\canasta_basica_urbana_PREPROCESADO.csv")

# Ver las columnas del dataset
df.columns

import pandas as pd


# Cargar el archivo CSV
df = pd.read_csv(r"C:\Users\Angel Temporal\CANASTA BASICA PROYECTO\DATA SET\URBANA\canasta_basica_urbana_PREPROCESADO.csv")

# Establecer el número máximo de decimales a mostrar
pd.set_option('display.float_format', '{:,.4f}'.format)


# Mostrar las primeras 60 filas para verificar
df.head()

"""# __ETAPA 2: FILTRAR LOS DATOS DEL PAN FRANCES__"""

# Filtrar solo el Pan Francés
df_pan = df[df["ARTICULO"] == "Pan Francés"].copy()


#df.drop(264, inplace=True)
df_pan = df_pan.drop(264, axis=0)

# Verificar el dataset filtrado

df_pan.head(25)

"""# __ETAPA 3: TRANFORMAR LOS DATOS EN UN FORMATO ANCHO A LARGO__"""

import pandas as pd

# Asegúrate de cargar el DataFrame 'df_pan' antes de ejecutar este código

# Transformar de formato ancho (varias columnas de meses) a largo (fecha única)
df_pan_melted = df_pan.melt(id_vars=["AÑO", "ARTICULO"],
                            value_vars=["ENERO", "FEBRERO", "MARZO", "ABRIL", "MAYO", "JUNIO",
                                        "JULIO", "AGOSTO", "SEPTIEMBRE", "OCTUBRE", "NOVIEMBRE", "DICIEMBRE"],
                            var_name="MES", value_name="PRECIO")

# Mapeo de nombres de meses a números
meses_dict = {
    "ENERO": 1, "FEBRERO": 2, "MARZO": 3, "ABRIL": 4, "MAYO": 5, "JUNIO": 6,
    "JULIO": 7, "AGOSTO": 8, "SEPTIEMBRE": 9, "OCTUBRE": 10, "NOVIEMBRE": 11, "DICIEMBRE": 12
}

# Convertir los nombres de los meses a números
df_pan_melted["MES"] = df_pan_melted["MES"].map(meses_dict)

# Crear la columna de fecha
df_pan_melted["FECHA"] = pd.to_datetime(df_pan_melted["AÑO"].astype(str) + "-" + df_pan_melted["MES"].astype(str) + "-01")

# Ordenar por fecha y eliminar columnas innecesarias
df_pan_melted = df_pan_melted.sort_values("FECHA")[["FECHA", "PRECIO"]]

# Reiniciar el índice
df_pan_melted.reset_index(drop=True, inplace=True)

df_pan_melted.index = df_pan_melted.index + 1


# Mostrar los primeros registros
df_pan_melted.head()

#VERIFICACION CORRECTA DE LAS SERIES TEMPORALES
df_pan_melted

"""# __ETAPA 4: GRAFICAR LA EVOLUCION DEL PRECIO DEL PAN FRANCES__"""

import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.dates as mdates
import numpy as np  # Para generar el rango de valores del eje Y

# Convertir la columna FECHA a datetime (si no lo está)
df_pan_melted["FECHA"] = pd.to_datetime(df_pan_melted["FECHA"])

# Graficar la serie temporal
plt.figure(figsize=(12,6))
plt.plot(df_pan_melted["FECHA"], df_pan_melted["PRECIO"], marker="o", linestyle="", color="b", label="Precio Pan Francés")

# Personalizar el eje X para mostrar un año por año
ax = plt.gca()
ax.xaxis.set_major_locator(mdates.YearLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))

# Definir los valores del eje Y manualmente
y_ticks = np.arange(0.0600, 0.1901, 0.0050)  # Desde 0.0600 hasta 0.1900, con incrementos de 0.0050
plt.yticks(y_ticks)

# Ajustar los límites del eje Y
#plt.ylim(0.0600, 0.1900)  # Establecer el rango del eje Y

# Formatear las etiquetas del eje Y para mostrar 4 decimales
ax.yaxis.set_major_formatter(plt.FormatStrFormatter('%.4f'))

plt.xlabel("Fecha")
plt.ylabel("Precio ($)")
plt.title("Evolución del Precio del Pan Francés")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.dates as mdates
import numpy as np  # Para generar el rango de valores del eje Y

# Convertir la columna FECHA a datetime (si no lo está)
df_pan_melted["FECHA"] = pd.to_datetime(df_pan_melted["FECHA"])

# Graficar la serie temporal
plt.figure(figsize=(12,6))
plt.plot(df_pan_melted["FECHA"], df_pan_melted["PRECIO"], marker="o", linestyle="-", color="b", label="Precio Pan Francés")

# Personalizar el eje X para mostrar un año por año
ax = plt.gca()
ax.xaxis.set_major_locator(mdates.YearLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))

# Definir los valores del eje Y manualmente
y_ticks = np.arange(0.0600, 0.1901, 0.0050)  # Desde 0.0600 hasta 0.1900, con incrementos de 0.0050
plt.yticks(y_ticks)

# Ajustar los límites del eje Y
#plt.ylim(0.0600, 0.1900)  # Establecer el rango del eje Y

# Formatear las etiquetas del eje Y para mostrar 4 decimales
ax.yaxis.set_major_formatter(plt.FormatStrFormatter('%.4f'))

plt.xlabel("Fecha")
plt.ylabel("Precio ($)")
plt.title("Evolución del Precio del Pan Francés")
plt.legend()
plt.grid()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## __DESCOMPOSICION DE LA SERIE TEMPORAL PARA ANALIZAR TENDENCIAS Y ESTACIONALIDAD__"""

from statsmodels.tsa.seasonal import seasonal_decompose

# Asegurar que la fecha es el índice
df_pan_melted.set_index("FECHA", inplace=True)

# Descomposición de la serie temporal
result = seasonal_decompose(df_pan_melted["PRECIO"], model="additive", period=12)

# Graficar los componentes de la descomposición
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))

# Tendencia
plt.subplot(3, 1, 1)
plt.plot(result.trend, label="Tendencia", color="tab:blue")
plt.legend()

# Estacionalidad
plt.subplot(3, 1, 2)
plt.plot(result.seasonal, label="Estacionalidad", color="tab:green")
plt.legend()

# Residuos
plt.subplot(3, 1, 3)
plt.plot(result.resid, label="Residuos", color="tab:red")
plt.legend()

plt.tight_layout()
plt.show()

"""# __ANALISIS DE LOS GRAFICOS__ :

## __Tendencia__: Se observa un crecimiento en el precio del pan a lo largo del tiempo, con aumentos significativos después de 2020.

## __Estacionalidad__: Hay fluctuaciones periódicas dentro de cada año, lo que sugiere que el precio del pan tiene un patrón estacional (posiblemente ligado a la demanda o producción anual).

## __Residuos__: Muestran cierta variabilidad, pero sin una tendencia clara, lo que indica que el modelo aditivo puede ser adecuado.

___

Dado que la serie tiene una tendencia clara y estacionalidad marcada, podemos probar un modelo basado en redes neuronales como LSTM (Long Short-Term Memory)

__Pasos del desarrollo del modelo LSTM__

__1 Preprocesamiento de datos__

    Normalización de los valores

    Creación de secuencias para LSTM

    División en datos de entrenamiento y prueba


__2 Construcción del modelo LSTM__

    Definir la arquitectura de la red neuronal

    Entrenamiento del modelo

__3 Evaluación y predicción__

    Generar predicciones en datos futuros

    Visualizar los resultados

___

# __1 Preprocesamiento de Datos__

## Cargar y normalizar datos
"""

print("Columnas disponibles:", df_pan_melted.columns)
print("Primeras filas del DataFrame:")
df_pan_melted.head()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

# Normalizar el precio entre 0 y 1
scaler = MinMaxScaler(feature_range=(0, 1))
df_pan_melted["PRECIO_NORMALIZADO"] = scaler.fit_transform(df_pan_melted["PRECIO"].values.reshape(-1, 1))

# Asegurar que "FECHA" sea una columna
df_pan_melted = df_pan_melted.reset_index()

# Visualizar datos normalizados
plt.figure(figsize=(12,6))
plt.plot(df_pan_melted["FECHA"], df_pan_melted["PRECIO_NORMALIZADO"], label="Precio Normalizado")
plt.xlabel("Fecha")
plt.ylabel("Precio (Normalizado)")
plt.title("Evolución del Precio del Pan Francés (Normalizado)")
plt.legend()
plt.show()

"""## Creación de secuencias para LSTM

## División en datos de entrenamiento y prueba
"""

def crear_secuencias(data, pasos=12):
    X, Y = [], []
    for i in range(len(data) - pasos):
        X.append(data[i:i+pasos])
        Y.append(data[i+pasos])
    return np.array(X), np.array(Y)

# Convertir la columna de precios normalizados en una serie de valores
precios_normalizados = df_pan_melted["PRECIO_NORMALIZADO"].values

# Definir longitud de la ventana de tiempo
pasos = 12  # Usaremos 12 meses (1 año) para predecir el siguiente valor

# Crear secuencias de entrada y salida
X, Y = crear_secuencias(precios_normalizados, pasos)

# Dividir en conjuntos de entrenamiento (80%) y prueba (20%)
train_size = int(len(X) * 0.8)
X_train, Y_train = X[:train_size], Y[:train_size]
X_test, Y_test = X[train_size:], Y[train_size:]

# Redimensionar para que LSTM lo acepte (batch_size, timesteps, features)
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

print("Forma de X_train:", X_train.shape)
print("Forma de Y_train:", Y_train.shape)
print("Forma de X_test:", X_test.shape)
print("Forma de Y_test:", Y_test.shape)

"""X_train.shape = (220, 12, 1) → 220 secuencias de 12 meses cada una.

Y_train.shape = (220,) → 220 valores de salida correspondientes.

X_test.shape = (56, 12, 1) → 56 secuencias para prueba.

Y_test.shape = (56,) → 56 valores de salida para prueba.

# __2 Construcción del modelo LSTM__
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Definir la arquitectura del modelo
modelo = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),  # Capa LSTM con 50 neuronas
    Dropout(0.2),  # Regularización para evitar sobreajuste
    LSTM(50, return_sequences=False),  # Segunda capa LSTM
    Dropout(0.2),
    Dense(25),  # Capa densa con 25 neuronas
    Dense(1)  # Capa de salida (1 valor de predicción)
])

# Compilar el modelo
modelo.compile(optimizer="adam", loss="mean_squared_error")

# Entrenar el modelo
historial = modelo.fit(X_train, Y_train, epochs=50, batch_size=16, validation_data=(X_test, Y_test))

import sys
print(sys.version)

"""# ETAPA 5: DIVISION DEL CONJUNTO DE DATOS"""

df_pan_melted["FECHA_ORD"] = df_pan_melted["FECHA"].map(lambda x: x.toordinal())

from sklearn.model_selection import train_test_split

# Variables independientes (X) y dependientes (y)
X = df_pan_melted[["FECHA_ORD"]]  # Matriz de características
y = df_pan_melted["PRECIO"]       # Variable objetivo

# División en entrenamiento y prueba (80% entrenamiento, 20% prueba)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

"""# ETAPA 6: ENTRENAMIENTO DEL MODELO DE REGRESION LINEAL"""

from sklearn.linear_model import LinearRegression

modelo = LinearRegression()

modelo.fit(X_train, y_train)

print(f"Pendiente (m): {modelo.coef_[0]}")
print(f"Intercepto (b): {modelo.intercept_}")

y_pred = modelo.predict(X_test)

import matplotlib.pyplot as plt

# 1 Gráfico de datos reales
plt.figure(figsize=(10,5))
plt.scatter(X_train, y_train, color='blue', label='Datos reales')  # Datos de entrenamiento

# 2 Graficar la línea de regresión
plt.plot(X_train, modelo.predict(X_train), color='red', linewidth=2, label='Regresión Lineal')

# 3 Personalización del gráfico
plt.xlabel("Fecha (ordinal)")
plt.ylabel("Precio del Pan Francés")
plt.title("Regresión Lineal - Predicción de Precios")
plt.legend()
plt.grid(True)

# 4 Mostrar gráfico
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import datetime

plt.figure(figsize=(10, 5))

# Convertir fechas ordinales a formato datetime
X_train_fechas = [datetime.date.fromordinal(int(fecha)) for fecha in X_train.values.flatten()]
fechas_futuras_fechas = [datetime.date.fromordinal(int(fecha)) for fecha in fechas_futuras_ordinal]

# Datos históricos
plt.scatter(X_train_fechas, y_train, color='blue', label='Datos reales')

# Línea de regresión en los datos históricos
plt.plot(X_train_fechas, modelo.predict(X_train), color='red', linewidth=2, label='Regresión Lineal')

# Predicciones futuras
plt.scatter(fechas_futuras_fechas, precios_predichos, color='green', label='Predicciones 2025-2030')

# 🔹 Formatear el eje X con fechas legibles
ax = plt.gca()
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))  # Formato Año-Mes
ax.xaxis.set_major_locator(mdates.YearLocator())  # Mostrar un año en cada marca

# Personalización del gráfico
plt.xlabel("Fecha")
plt.ylabel("Precio del Pan Francés")
plt.title("Predicción de Precios del Pan Francés (2025-2030)")
plt.legend()
plt.grid(True)

plt.xticks(rotation=45)  # Rotar etiquetas para mejor visualización
plt.show()

# ================= ETAPA 7: Evaluación del Modelo =================
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f"MAE: {mae}, RMSE: {rmse}")

# ================= ETAPA 8: Visualización de Resultados =================
plt.figure(figsize=(10,5))
plt.plot(df_melted["FECHA"], df_melted["PRECIO"], label="Datos reales", marker="o", linestyle="-")
plt.plot(df_melted.iloc[len(X_train):]["FECHA"], y_pred, label="Predicciones", marker="x", linestyle="--", color="red")
plt.xlabel("Fecha")
plt.ylabel("Precio del Pan Francés")
plt.title("Predicción de Precios con Regresión Lineal")
plt.legend()
plt.show()

# ================= ETAPA 9: Predicción para 2025 en adelante =================
future_dates = pd.date_range(start="2025-01-01", periods=36, freq='M')  # 3 años futuros
future_ordinal = np.array([date.toordinal() for date in future_dates]).reshape(-1, 1)

# Hacer predicciones para los años futuros
future_prices = model.predict(future_ordinal)

# Mostrar predicciones
future_df = pd.DataFrame({"FECHA": future_dates, "PRECIO_PREDICHO": future_prices})
print(future_df.head())

# Visualizar predicciones futuras
plt.figure(figsize=(10,5))
plt.plot(df_melted["FECHA"], df_melted["PRECIO"], label="Datos reales", marker="o", linestyle="-")
plt.plot(future_df["FECHA"], future_df["PRECIO_PREDICHO"], label="Predicción 2025+", marker="x", linestyle="--", color="green")
plt.xlabel("Fecha")
plt.ylabel("Precio del Pan Francés")
plt.title("Predicción de Precios del Pan Francés hasta 2027")
plt.legend()
plt.show()

import tensorflow as tf
print(tf.__version__)

